## Webpack4 官方案例解读

> 注：从 webpack-demo-5 开始为官方案列，官方案列在 webpack/examples 里

### Aggressive Merging  高效合并

1. 通过内置插件AggressiveMergingPlugin实现

2. 原理：从不同合并代码组合中寻找最优组合，指标为组合转化比：improvement = (aSize + bSize) / abSize，很明显，越大说明此种组合最优

3. 核心源码(部分删减)
```js
  apply(compiler) {
    const options = this.options;
    const minSizeReduce = this.options.minSizeReduce || 1.5;

    compiler.hooks.thisCompilation.tap(
      "AggressiveMergingPlugin",
      compilation => {
        compilation.hooks.optimizeChunks.tap(
          {
            name: "AggressiveMergingPlugin",
            stage: STAGE_ADVANCED
          },
          chunks => {
            const chunkGraph = compilation.chunkGraph;
            /** @type {{a: Chunk, b: Chunk, improvement: number}[]} */
            let combinations = [];
            for (const a of chunks) {
              // if (a.canBeInitial()) continue;
              for (const b of chunks) {
                // if (b.canBeInitial()) continue;
                // if (b === a) break;
                // if (!chunkGraph.canChunksBeIntegrated(a, b)) {continue;}
                const aSize = chunkGraph.getChunkSize(b, {chunkOverhead: 0});
                const bSize = chunkGraph.getChunkSize(a, {chunkOverhead: 0});
                const abSize = chunkGraph.getIntegratedChunksSize(b, a, {chunkOverhead: 0});
                const improvement = (aSize + bSize) / abSize;
                combinations.push({a, b, improvement});
              }
            }

            combinations.sort((a, b) => {
              return b.improvement - a.improvement;
            });

            const pair = combinations[0];

            console.log('得到最终提高率最大的chunk', pair)

            if (!pair) return;
            if (pair.improvement < minSizeReduce) return;

            chunkGraph.integrateChunks(pair.b, pair.a);
            compilation.chunks.delete(pair.a);
            return true;
          }
        );
      }
    );
  }
```

4. production模式下，该内置插件会生效，默认的minSizeReduce值为1.5，当然我们也可以手动配置该插件
以下分别为开发模式下未配置该插件，开发模式下配置该插件，生产模式下打包后截图(注：生产模式下不止这一个内置插件起作用)
![开发模式下未配置该插件打包](https://github.com/Matthrews/webpack-demos/blob/main/webpack-demo-5/imgs/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9C%AA%E9%85%8D%E7%BD%AE%E8%AF%A5%E6%8F%92%E4%BB%B6.png)
![开发模式下配置该插件打包](https://github.com/Matthrews/webpack-demos/blob/main/webpack-demo-5/imgs/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%AF%A5%E6%8F%92%E4%BB%B6.png)
![生产模式下打包](https://github.com/Matthrews/webpack-demos/blob/main/webpack-demo-5/imgs/%E7%94%9F%E4%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%8B.png)

5. 源代码 [webpack-demo-5](https://github.com/Matthrews/webpack-demos)

### Chunk  数据块

#### chunkhash  数据块哈希
1. 通过`optimization.runtimeChunk`配置，原理是将入口文件里的仅含runtime的文件(`runtime~main.xx.js`)单独打包出来，这样就可以充分对入口文件`main.js`进行长期缓存，而多出来的`runtime`文件可以通过`inline`的方式插入`html`，这样在请求数不变的基础上还实现了长期缓存。

2. 先看看配置前的状况
  ![使用runtimeChunk之前](C:\Users\Matthew\webpack-demos\webpack-demo-6\imgs\使用runtimeChunk之前.png)

  显然我们可以发现，当我们修改`acyns1.js`(打包结果为`114.xx.js`文件)之后，因为入口文件(此处为`main.xx.js`文件)引入了`acyns1.js`文件，所以当`acyns1.js`文件发生变化时，`main.xx.js`文件也会修改，这意味着重新发起请求，那么是否可以实现修改`acyns1.js`只会引起本文件hash值修改而不会影响到`main.xx.js`文件呢？答案是肯定的。

3. 配置`runtimeChunk`后`webpack.config.js`配置如下

   ```js
   module.exports = {
       // mode: "development || "production",
       entry: {
           main: "./example"
       },
       optimization: {
           runtimeChunk: true
       },
       output: {
           path: path.join(__dirname, "dist"),
           filename: "[name].[chunkhash].js",
           chunkFilename: "[name].[chunkhash].js"
       },
       plugins: [
           new HtmlWebpackPlugin({
               template: './template.html'
           }),
           new ScriptExtHtmlWebpackPlugin({
               inline: /runtime~.+\.js$/  //正则匹配runtime文件名
           })
       ]
   };
   ```

   通过`ScriptExtHtmlWebpackPlugin`插件完成runtime文件内联到html中，如下图

   ![内联js](C:\Users\Matthew\webpack-demos\webpack-demo-6\imgs\内联js.png)

4. 再次修改`acyns1.js`文件后，打包截图如下

   ![使用runtimeChunk之后](C:\Users\Matthew\webpack-demos\webpack-demo-6\imgs\使用runtimeChunk之后.png)

#### common-chunk-and-vendor-chunk  公共数据块和三方数据块

#### explicit-vendor-chunk

#### extra-async-chunk-advanced

#### extra-async-chunk

#### code-splitting-specify-chunk-name

#### named-chunks]

#### two-explicit-vendor-chunks

### Code Split
### Code Splitting
### Coffee Script
### CommonJS
### DLL
### Externals
### Harmony
### HTTP2 Aggressive Splitting
### Hybrid Routing
### Loader
### Mixed
### Multi Compiler
### Multi Part Library
### Multiple Entry Points
### Require Context
### Require Resolve
### Scope Hoisting
### Side Effects
### Source Map
### Web Worker
### Requests
### Building an Example
